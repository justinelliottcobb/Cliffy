/**
 * Cliffy - Reactive FRP framework powered by geometric algebra
 *
 * This is a thin TypeScript wrapper around the Cliffy WASM core.
 *
 * @example
 * ```typescript
 * import { init, behavior, event, when, combine } from '@cliffy/core';
 *
 * // Initialize WASM (required before using any other functions)
 * await init();
 *
 * // Create reactive state
 * const count = behavior(0);
 *
 * // Subscribe to changes
 * count.subscribe(n => console.log('Count:', n));
 *
 * // Update state
 * count.update(n => n + 1);  // Logs: Count: 1
 * ```
 *
 * @packageDocumentation
 */

// Import WASM bindings (will be generated by wasm-pack)
import wasmInit, {
  Behavior as WasmBehavior,
  Event as WasmEvent,
  Subscription as WasmSubscription,
  behavior as wasmBehavior,
  event as wasmEvent,
  when as wasmWhen,
  ifElse as wasmIfElse,
  combine as wasmCombine,
  constant as wasmConstant,
  version as wasmVersion,
} from '../pkg/cliffy_wasm.js';

// Export the init function
export const init = wasmInit;

// Re-export version
export const version = wasmVersion;

/**
 * A reactive value that changes over time.
 *
 * Behavior represents a continuous value - it always has a current value
 * that can be sampled at any time. When the value changes, all subscribers
 * are notified.
 *
 * @typeParam T - The type of value this behavior holds
 *
 * @example
 * ```typescript
 * const count = behavior(0);
 *
 * // Get current value
 * console.log(count.sample()); // 0
 *
 * // Update value
 * count.update(n => n + 1);
 * console.log(count.sample()); // 1
 *
 * // Subscribe to changes
 * count.subscribe(n => console.log('Changed to:', n));
 * ```
 */
export class Behavior<T> {
  private inner: WasmBehavior;

  constructor(initial: T) {
    this.inner = new WasmBehavior(initial);
  }

  /** Create a Behavior from an existing WASM Behavior */
  static fromWasm<T>(wasm: WasmBehavior): Behavior<T> {
    const b = Object.create(Behavior.prototype);
    b.inner = wasm;
    return b;
  }

  /**
   * Sample the current value.
   *
   * @returns The current value of this behavior
   */
  sample(): T {
    return this.inner.sample() as T;
  }

  /**
   * Set the value directly.
   *
   * @param value - The new value
   */
  set(value: T): void {
    this.inner.set(value);
  }

  /**
   * Update the value using a transformation function.
   *
   * @param f - A function that receives the current value and returns the new value
   */
  update(f: (value: T) => T): void {
    this.inner.update(f);
  }

  /**
   * Subscribe to value changes.
   *
   * @param callback - Function called whenever the value changes
   * @returns A subscription that can be used to unsubscribe
   */
  subscribe(callback: (value: T) => void): Subscription {
    const sub = this.inner.subscribe(callback);
    return new Subscription(sub);
  }

  /**
   * Create a derived behavior by mapping a function over this one.
   *
   * The derived behavior will automatically update when this behavior changes.
   *
   * @param f - Transformation function
   * @returns A new behavior with the transformed value
   */
  map<U>(f: (value: T) => U): Behavior<U> {
    const mapped = this.inner.map(f);
    return Behavior.fromWasm<U>(mapped);
  }

  /**
   * Combine this behavior with another using a function.
   *
   * @param other - The other behavior to combine with
   * @param f - Function that combines both values
   * @returns A new behavior with the combined value
   */
  combine<U, V>(other: Behavior<U>, f: (a: T, b: U) => V): Behavior<V> {
    const combined = this.inner.combine(other.inner, f);
    return Behavior.fromWasm<V>(combined);
  }

  /** Get the underlying WASM behavior */
  get _wasm(): WasmBehavior {
    return this.inner;
  }
}

/**
 * A stream of discrete events.
 *
 * Event represents discrete occurrences - unlike Behavior, it doesn't
 * have a "current value". Events are emitted and subscribers are
 * notified when they occur.
 *
 * @typeParam T - The type of value each event carries
 *
 * @example
 * ```typescript
 * const clicks = event<MouseEvent>();
 *
 * clicks.subscribe(e => {
 *   console.log('Clicked at:', e.clientX, e.clientY);
 * });
 *
 * // Emit an event
 * clicks.emit({ clientX: 100, clientY: 200 });
 * ```
 */
export class Event<T> {
  private inner: WasmEvent;

  constructor() {
    this.inner = new WasmEvent();
  }

  /** Create an Event from an existing WASM Event */
  static fromWasm<T>(wasm: WasmEvent): Event<T> {
    const e = Object.create(Event.prototype);
    e.inner = wasm;
    return e;
  }

  /**
   * Emit a value to all subscribers.
   *
   * @param value - The value to emit
   */
  emit(value: T): void {
    this.inner.emit(value);
  }

  /**
   * Subscribe to this event stream.
   *
   * @param callback - Function called whenever an event occurs
   * @returns A subscription that can be used to unsubscribe
   */
  subscribe(callback: (value: T) => void): Subscription {
    const sub = this.inner.subscribe(callback);
    return new Subscription(sub);
  }

  /**
   * Map a function over this event stream.
   *
   * @param f - Transformation function
   * @returns A new event stream with transformed values
   */
  map<U>(f: (value: T) => U): Event<U> {
    const mapped = this.inner.map(f);
    return Event.fromWasm<U>(mapped);
  }

  /**
   * Filter events based on a predicate.
   *
   * @param predicate - Function that returns true for events to keep
   * @returns A new event stream with only matching events
   */
  filter(predicate: (value: T) => boolean): Event<T> {
    const filtered = this.inner.filter(predicate);
    return Event.fromWasm<T>(filtered);
  }

  /**
   * Merge this event stream with another.
   *
   * @param other - The other event stream to merge with
   * @returns A new event stream that emits from both sources
   */
  merge(other: Event<T>): Event<T> {
    const merged = this.inner.merge(other.inner);
    return Event.fromWasm<T>(merged);
  }

  /**
   * Fold events into a behavior, accumulating values.
   *
   * @param initial - The initial accumulated value
   * @param f - Function that takes (accumulator, event) and returns new accumulator
   * @returns A behavior containing the accumulated value
   */
  fold<S>(initial: S, f: (acc: S, value: T) => S): Behavior<S> {
    const behavior = this.inner.fold(initial, f);
    return Behavior.fromWasm<S>(behavior);
  }

  /** Get the underlying WASM event */
  get _wasm(): WasmEvent {
    return this.inner;
  }
}

/**
 * A subscription handle that can be used to unsubscribe.
 */
export class Subscription {
  private inner: WasmSubscription;

  constructor(inner: WasmSubscription) {
    this.inner = inner;
  }

  /**
   * Unsubscribe from the behavior or event.
   */
  unsubscribe(): void {
    this.inner.unsubscribe();
  }
}

// ============================================================================
// Convenience Functions
// ============================================================================

/**
 * Create a new Behavior with an initial value.
 *
 * @param initial - The initial value
 * @returns A new Behavior
 *
 * @example
 * ```typescript
 * const count = behavior(0);
 * const name = behavior('Alice');
 * const items = behavior<string[]>([]);
 * ```
 */
export function behavior<T>(initial: T): Behavior<T> {
  return new Behavior(initial);
}

/**
 * Create a new Event stream.
 *
 * @returns A new Event stream
 *
 * @example
 * ```typescript
 * const clicks = event<MouseEvent>();
 * const messages = event<string>();
 * ```
 */
export function event<T>(): Event<T> {
  return new Event<T>();
}

// ============================================================================
// Combinators
// ============================================================================

/**
 * Create a Behavior that holds a value only when a condition is true.
 *
 * @param condition - A Behavior that controls visibility
 * @param thenValue - A function that returns the value when condition is true
 * @returns A Behavior that holds the value when true, or null when false
 *
 * @example
 * ```typescript
 * const showMessage = behavior(true);
 * const message = when(showMessage, () => "Hello!");
 *
 * console.log(message.sample()); // "Hello!"
 *
 * showMessage.set(false);
 * console.log(message.sample()); // null
 * ```
 */
export function when<T>(
  condition: Behavior<boolean>,
  thenValue: () => T
): Behavior<T | null> {
  const result = wasmWhen(condition._wasm, thenValue);
  return Behavior.fromWasm<T | null>(result);
}

/**
 * Create a Behavior that selects between two values based on a condition.
 *
 * @param condition - A Behavior that controls selection
 * @param thenValue - A function that returns the value when condition is true
 * @param elseValue - A function that returns the value when condition is false
 * @returns A Behavior with the selected value
 *
 * @example
 * ```typescript
 * const isDarkMode = behavior(false);
 * const theme = ifElse(isDarkMode, () => "dark", () => "light");
 *
 * console.log(theme.sample()); // "light"
 *
 * isDarkMode.set(true);
 * console.log(theme.sample()); // "dark"
 * ```
 */
export function ifElse<T>(
  condition: Behavior<boolean>,
  thenValue: () => T,
  elseValue: () => T
): Behavior<T> {
  const result = wasmIfElse(condition._wasm, thenValue, elseValue);
  return Behavior.fromWasm<T>(result);
}

/**
 * Combine two Behaviors into one using a function.
 *
 * @param a - First Behavior
 * @param b - Second Behavior
 * @param f - A function that takes both values and returns the combined value
 * @returns A new Behavior with the combined value
 *
 * @example
 * ```typescript
 * const width = behavior(100);
 * const height = behavior(50);
 * const area = combine(width, height, (w, h) => w * h);
 *
 * console.log(area.sample()); // 5000
 * ```
 */
export function combine<A, B, C>(
  a: Behavior<A>,
  b: Behavior<B>,
  f: (a: A, b: B) => C
): Behavior<C> {
  const result = wasmCombine(a._wasm, b._wasm, f);
  return Behavior.fromWasm<C>(result);
}

/**
 * Create a Behavior with a constant value.
 *
 * @param value - The constant value
 * @returns A Behavior that always holds this value
 *
 * @example
 * ```typescript
 * const pi = constant(3.14159);
 * console.log(pi.sample()); // 3.14159
 * ```
 */
export function constant<T>(value: T): Behavior<T> {
  const result = wasmConstant(value);
  return Behavior.fromWasm<T>(result);
}

// ============================================================================
// DOM Bindings
// ============================================================================

export * from './dom.js';
